{"/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/test.js":"/* istanbul instrument in package npmtest_simple_autoreload_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/lib.npmtest_simple_autoreload_server.js":"/* istanbul instrument in package npmtest_simple_autoreload_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_simple_autoreload_server = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_simple_autoreload_server = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-simple-autoreload-server && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_simple_autoreload_server */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_simple_autoreload_server\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_simple_autoreload_server.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_simple_autoreload_server.rollup.js'] =\n            local.assetsDict['/assets.npmtest_simple_autoreload_server.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_simple_autoreload_server.__dirname + '/lib.npmtest_simple_autoreload_server.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/node_modules/simple-autoreload-server/index.js":"/*\n * simple-autoreload-server v0.2.6 - 2016-10-14\n * <https://github.com/cytb/simple-autoreload-server>\n *\n * Copyright (c) 2016 cytb\n *\n * Licensed under the MIT License.\n */\n\n(function(){\n  module.exports = function(){\n    var autoreload, exports;\n    autoreload = require('./lib/autoreload');\n    exports = function(it){\n      var server;\n      server = new autoreload.SimpleAutoreloadServer(it);\n      server.start();\n      return server;\n    };\n    return import$(exports, autoreload);\n  }();\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/node_modules/simple-autoreload-server/lib/autoreload.js":"/*\n * simple-autoreload-server v0.2.6 - 2016-10-14\n * <https://github.com/cytb/simple-autoreload-server>\n *\n * Copyright (c) 2016 cytb\n *\n * Licensed under the MIT License.\n */\n\n(function(){\n  var http, https, fs, path, child_process, opener, connect, colors, WebSocket, RecursiveWatcher, OptionHelper, Injecter, InjectionRouter, SimpleAutoreloadServer, slice$ = [].slice, this$ = this, out$ = typeof exports != 'undefined' && exports || this;\n  http = require('http');\n  https = require('https');\n  fs = require('fs');\n  path = require('path');\n  child_process = require('child_process');\n  opener = require('opener');\n  connect = require('connect');\n  colors = require('colors');\n  WebSocket = require('faye-websocket');\n  RecursiveWatcher = require('./watch').RecursiveWatcher;\n  OptionHelper = require('./option').OptionHelper;\n  Injecter = (function(){\n    Injecter.displayName = 'Injecter';\n    var prototype = Injecter.prototype, constructor = Injecter;\n    function Injecter(arg$){\n      var flag;\n      this.content = arg$.content, this.ignoreCase = arg$.ignoreCase, this.type = arg$.type, this.which = arg$.which, this.where = arg$.where, this.prepend = arg$.prepend, this.includeHidden = arg$.includeHidden, this.encoding = arg$.encoding;\n      this.fileMatcher = OptionHelper.readPattern(this.which, this.ignoreCase, this.includeHidden);\n      if (this.where instanceof RegExp) {\n        this.contentRegex = this.where;\n      } else {\n        flag = this.ignoreCase === false && \"\" || \"i\";\n        this.contentRegex = new RegExp(this.where, flag);\n      }\n      this.lengthOf = this.prepend && function(){\n        return 0;\n      } || function(it){\n        return it.length;\n      };\n      this.getCode = (function(){\n        var ref$;\n        switch (ref$ = [this.type], false) {\n        case \"raw\" !== ref$[0]:\n          return function(){\n            return this.content;\n          };\n        case \"file\" !== ref$[0]:\n          return this.constructor.getCachedLoader(process.cwd(), this.content, this.encoding);\n        default:\n          return function(){\n            return this.content;\n          };\n        }\n      }.call(this));\n    }\n    prototype.isTarget = function(it){\n      return this.fileMatcher(it);\n    };\n    prototype.matchContent = function(it){\n      return this.contentRegex.exec(it);\n    };\n    prototype.inject = function(file, text){\n      var m, pos;\n      if (this.isTarget(file) && (m = this.matchContent(text))) {\n        pos = m.index + this.lengthOf(m[0]);\n        text = text.slice(0, pos) + \"\" + this.getCode() + text.slice(pos);\n      }\n      return text;\n    };\n    Injecter.create = function(it){\n      return new Injecter(it);\n    };\n    Injecter.getCachedLoader = function(base, file, enc){\n      var last, p, cached;\n      enc == null && (enc = 'utf-8');\n      last = null;\n      p = path.resolve(base, file);\n      cached = \"\";\n      return function(){\n        var mtime;\n        mtime = fs.statSync(p).mtime;\n        if (last !== mtime) {\n          cached = fs.readFileSync(p, {\n            encoding: enc\n          });\n          cached = cached.toString();\n          last = mtime;\n        }\n        return cached;\n      };\n    };\n    return Injecter;\n  }());\n  InjectionRouter = (function(){\n    InjectionRouter.displayName = 'InjectionRouter';\n    var prototype = InjectionRouter.prototype, constructor = InjectionRouter;\n    function InjectionRouter(arg$){\n      this.path = arg$.path, this.target = arg$.target, this.inject = arg$.inject, this.defaultPages = arg$.defaultPages, this.encoding = arg$.encoding, this.listDirectory = arg$.listDirectory;\n      this.injecters = this.inject.map(bind$(Injecter, 'create'));\n      this.defaultPages = OptionHelper.readPattern(this.defaultPages);\n    }\n    prototype.route = function(req, res, next){\n      var ref$, url, rel, file, isDirpath, stat, dir, files, text, e;\n      if (!((ref$ = req.method) === 'GET' || ref$ === 'HEAD')) {\n        next();\n      }\n      url = connect.utils.parseUrl(req);\n      rel = path.relative(this.target, url.pathname);\n      file = path.resolve(this.path, rel);\n      isDirpath = url.pathname.charAt(url.pathname.length - 1);\n      try {\n        stat = fs.statSync(file);\n        if (stat.isDirectory() && isDirpath) {\n          dir = file;\n          files = fs.readdirSync(dir).map(partialize$.apply(path, [path.join, [dir, void 8], [1]])).filter(function(name){\n            var ref$, e;\n            try {\n              return (ref$ = fs.statSync(name)) != null ? ref$.isFile() : void 8;\n            } catch (e$) {\n              e = e$;\n              return false;\n            }\n          }).sort().filter(bind$(this, 'defaultPages'));\n          if (files.length > 0) {\n            file = files[0];\n            stat = fs.statSync(file);\n          }\n        }\n        if (!(stat.isFile() && this.injecters.some(function(it){\n          return it.isTarget(file);\n        }))) {\n          return next();\n        }\n        text = fs.readFileSync(file, {\n          encoding: this.encoding\n        });\n        text = this.injecters.reduce(function(){\n          return arguments[1].inject(file, arguments[0]);\n        }, text);\n        res.setHeader(\"Content-Length\", Buffer.byteLength(text));\n        res.setHeader(\"Content-Type\", \"text/html\");\n        return res.end(text, this.encoding);\n      } catch (e$) {\n        e = e$;\n        return next();\n      }\n    };\n    return InjectionRouter;\n  }());\n  SimpleAutoreloadServer = (function(){\n    SimpleAutoreloadServer.displayName = 'SimpleAutoreloadServer';\n    var prototype = SimpleAutoreloadServer.prototype, constructor = SimpleAutoreloadServer;\n    SimpleAutoreloadServer.logPrefix = function(host){\n      return (\"[autoreload #\" + process.pid + \" \" + host + \"]\").cyan;\n    };\n    function SimpleAutoreloadServer(option){\n      option == null && (option = {});\n      this.websockets = [];\n      this.running = false;\n      this.setupOptions(option);\n    }\n    prototype.setupOptions = function(options, logger){\n      var optionHelper, getRootDef, defaults, defaultsSrc, key, names, base, ref$, i$, len$, def, assured, json, preFile, file, dir, nextDir, x$, newBase, y$, ref1$, out;\n      logger == null && (logger = function(){});\n      options = import$({}, options);\n      optionHelper = new OptionHelper;\n      getRootDef = function(pname, name, alter){\n        alter == null && (alter = name);\n        return function(options, defMap){\n          var that, ref$, ref1$, ref2$;\n          switch (false) {\n          case (that = (ref$ = options[pname]) != null ? ref$[name] : void 8) == null:\n            return that;\n          case !(that = (ref1$ = options[pname]) != null ? (ref2$ = ref1$[0]) != null ? ref2$[name] : void 8 : void 8):\n            return that;\n          case (that = options[name]) == null:\n            return that;\n          default:\n            return defMap[alter];\n          }\n        };\n      };\n      defaults = {};\n      defaultsSrc = {\n        mount: ['watch', 'recursive', 'followSymlinks', 'ignoreCase', 'includeHidden'],\n        inject: ['where', 'which', 'type', 'prepend', 'includeHidden']\n      };\n      for (key in defaultsSrc) {\n        names = defaultsSrc[key];\n        base = (ref$ = defaults[key]) != null\n          ? ref$\n          : defaults[key] = {};\n        for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {\n          def = names[i$];\n          base[def] = getRootDef(key, def);\n        }\n      }\n      assured = optionHelper.assure(options, defaults);\n      json = null;\n      preFile = file = null;\n      dir = null;\n      if (assured.searchConfig) {\n        nextDir = process.cwd();\n        do {\n          dir = nextDir;\n          preFile = file;\n          file = path.resolve(dir, assured.config);\n          try {\n            x$ = fs.readFileSync(file, {\n              encoding: this.encoding\n            });\n            json = JSON.parse(x$.toString());\n          } catch (e$) {}\n          nextDir = path.join(dir, \"..\");\n        } while (json == null && preFile !== file);\n      }\n      base = json != null\n        ? json\n        : {};\n      if (json != null) {\n        this.basedir = path.resolve(dir, path.dirname(file));\n        process.chdir(this.basedir);\n      } else {\n        this.basedir = process.cwd();\n      }\n      newBase = import$(import$({}, base), options);\n      for (i$ = 0, len$ = (ref$ = ['inject', 'mount']).length; i$ < len$; ++i$) {\n        y$ = ref$[i$];\n        newBase[y$] = [].concat((ref1$ = base[y$]) != null\n          ? ref1$\n          : [], (ref1$ = options[y$]) != null\n          ? ref1$\n          : []);\n      }\n      out = optionHelper.assure(newBase, defaults);\n      if (out.inject == null || out.inject.length < 1) {\n        out.inject = [];\n        try {\n          file = path.resolve(this.basedir, '.autoreload.html');\n          if ((ref$ = fs.lstatSync(file)) != null && ref$.isFile()) {\n            out.inject.push({\n              content: file\n            });\n          }\n        } catch (e$) {}\n        out = optionHelper.assure(out, defaults);\n      }\n      if (!(out.onmessage instanceof Function)) {\n        out.onmessage = function(){};\n      }\n      this.options = out;\n      if (json != null) {\n        this.log(\"verbose\", \"options\", \"config loaded: \" + file);\n        return this.log(\"verbose\", \"options\", \"change working directory to \" + dir);\n      }\n    };\n    prototype.logLevel = [\n      {\n        level: 'silent',\n        tags: []\n      }, {\n        level: 'minimum',\n        tags: ['normal', 'error']\n      }, {\n        level: 'normal',\n        tags: ['normal', 'info', 'error']\n      }, {\n        level: 'verbose',\n        tags: ['normal', 'info', 'error', 'verbose']\n      }, {\n        level: 'noisy',\n        tags: ['normal', 'info', 'error', 'verbose', 'debug']\n      }\n    ];\n    prototype.logLevelMap = {\n      silent: 0,\n      minimum: 1,\n      normal: 2,\n      verbose: 3,\n      noisy: 4\n    };\n    prototype.getLogLevel = function(level){\n      var i$, to$, i;\n      level == null && (level = \"normal\");\n      switch (false) {\n      case typeof level !== \"boolean\":\n        return level && 2 || 0;\n      case typeof level !== \"string\":\n        for (i$ = 0, to$ = this.logLevel.length; i$ < to$; ++i$) {\n          i = i$;\n          if (this.logLevel[i].level === level) {\n            return i;\n          }\n        }\n        return 2;\n      case !(0 <= level && level < this.logLevel.length):\n        return level;\n      default:\n        return 2;\n      }\n    };\n    prototype.log = function(mode, tag, text){\n      var level, coloredTag, prefix;\n      level = this.getLogLevel(this.options.log);\n      if (!in$(mode, this.logLevel[level].tags)) {\n        return;\n      }\n      coloredTag = (function(){\n        var ref$;\n        switch (ref$ = [mode], false) {\n        case 'error' !== ref$[0]:\n          return (\"error@\" + tag).red;\n        default:\n          return tag.green;\n        }\n      }());\n      prefix = this.constructor.logPrefix(\"localhost:\" + this.options.port);\n      return console.log(prefix + \" \" + coloredTag + \" \" + text);\n    };\n    prototype.stop = function(){\n      var ref$, ref1$, ex;\n      try {\n        if ((ref$ = this.watcher) != null) {\n          ref$.stop();\n        }\n        if ((ref1$ = this.server) != null) {\n          ref1$.close();\n        }\n        this.running = false;\n        return this.log(\"normal\", \"server\", \"stopped.\");\n      } catch (e$) {\n        ex = e$;\n        return this.log(\"error\", \"server\", ex.message);\n      }\n    };\n    prototype.start = function(done){\n      var mounts, ref$, dirs, res$, i$, x$, len$, ex, listen, y$, this$ = this;\n      mounts = [];\n      try {\n        if (this.running) {\n          this.stop();\n        }\n        mounts = mounts.concat((ref$ = import$({}, this.options), ref$.target = \"/\", ref$));\n        mounts = mounts.concat((ref$ = this.options.mount) != null\n          ? ref$\n          : []);\n        res$ = [];\n        for (i$ = 0, len$ = mounts.length; i$ < len$; ++i$) {\n          x$ = mounts[i$];\n          res$.push((ref$ = import$({}, x$), ref$.path = path.resolve(this.basedir, x$.path), ref$));\n        }\n        dirs = res$;\n        this.watchers = this.createWatchers(dirs);\n        this.server = this.createServer(dirs);\n        this.watchers.map(function(it){\n          return it.start();\n        });\n      } catch (e$) {\n        ex = e$;\n        this.log(\"error\", \"server\", ex.message);\n        this.log(\"error\", \"server\", ex.stack);\n        if (done != null) {\n          done(ex, this);\n        }\n        return null;\n      }\n      listen = {\n        port: (ref$ = this.options).port,\n        host: ref$.host,\n        path: ref$.path\n      };\n      y$ = this.server;\n      y$.on('upgrade', function(req, sock, head){\n        var addr, x$;\n        if (!WebSocket.isWebSocket(req)) {\n          return;\n        }\n        addr = sock.remoteAddress + \":\" + sock.remotePort;\n        x$ = new WebSocket(req, sock, head);\n        x$.on('open', function(){\n          this$.log(\"verbose\", 'websocket', addr + \" - new connection\");\n          return x$.send(JSON.stringify({\n            type: 'open',\n            log: this$.options.clientLog\n          }));\n        });\n        x$.on('message', function(arg$){\n          var data;\n          data = arg$.data;\n          this$.log(\"verbose\", 'websocket', addr + \" - received message \" + data);\n          return this$.options.onmessage(data, x$);\n        });\n        x$.on('close', function(){\n          this$.log(\"verbose\", 'websocket', addr + \" - connection closed\");\n          return this$.websockets = this$.websockets.filter((function(it){\n            return it !== x$;\n          }));\n        });\n        this$.websockets.push(x$);\n        return x$;\n      });\n      y$.on('error', function(err){\n        var ref$;\n        switch (ref$ = [err.code], false) {\n        case 'EADDRINUSE' !== ref$[0]:\n          this$.log(\"error\", 'server', \"Cannot use \" + (listen.host + \"\").green + \":\" + (listen.port + \"\").green + \" as a listen address. Error: \" + err.message + \"\");\n          return this$.watchers.map(function(it){\n            return it.stop();\n          });\n        }\n      });\n      y$.listen(listen.port | 0, listen.host, 511, function(){\n        var i$, x$, ref$, len$, that, y$, child, port, address, serverUrl;\n        this$.running = true;\n        this$.abspath = path.resolve(process.cwd(), listen.path) + \"\";\n        for (i$ = 0, len$ = (ref$ = mounts.slice(1)).length; i$ < len$; ++i$) {\n          x$ = ref$[i$];\n          this$.log(\"info\", \"server\", \"mounted \" + x$.path + \" to \" + x$.target);\n        }\n        this$.log(\"normal\", \"server\", \"started on :\" + (listen.port + \"\").green + \" at \" + this$.abspath);\n        if (that = this$.options.execute != null && this$.options.execute) {\n          this$.log(\"info\", \"server\", \"execute command: \" + that);\n          y$ = child = child_process.exec(that, {\n            stdio: 'ignore'\n          });\n          y$.unref();\n          if (this$.options.stopOnExit) {\n            this$.log(\"info\", \"server\", \"server will stop when the command has exit.\");\n            child.on('exit', function(){\n              this$.log(\"info\", \"server\", \"child command has finished.\");\n              return this$.stop();\n            });\n          }\n        }\n        if (this$.options.browse) {\n          ref$ = this$.server.address(), port = ref$.port, address = ref$.address;\n          if (address === '0.0.0.0' || address === '::') {\n            address = \"localhost\";\n          }\n          serverUrl = (function(){\n            switch (typeof this.options.browse) {\n            case \"string\":\n              return this.options.browse;\n            default:\n              return \"http://\" + address + \":\" + port + \"/\";\n            }\n          }.call(this$));\n          this$.log(\"info\", \"server\", \"open \" + serverUrl);\n          opener(serverUrl, {\n            stdio: 'ignore'\n          }).unref();\n        }\n        if (done != null) {\n          return done(null, this$);\n        }\n      });\n      return y$;\n    };\n    prototype.createWatchers = function(dirs){\n      var shouldReload, watchObjs, this$ = this;\n      if (this.options.recursive) {\n        this.log(\"verbose\", \"server\", \"init with recursive-option. this may take a while.\");\n      }\n      shouldReload = OptionHelper.readPattern(this.options.reload, this.options.ignoreCase, this.options.includeHidden);\n      watchObjs = dirs.map(function(dir){\n        var matcher;\n        matcher = OptionHelper.readPattern(dir.watch, dir.ignoreCase, dir.includeHidden);\n        return new RecursiveWatcher(import$(clone$(dir), {\n          delay: this$.options.watchDelay,\n          error: function(arg$, src){\n            var message;\n            message = arg$.message;\n            return this$.log(\"error\", \"watch\", src + \" Error: \" + message);\n          },\n          update: function(arg$, target){\n            var httpPath, that;\n            if (!matcher(target)) {\n              return this$.log(\"debug\", \"watch\", \"(ignored)\".cyan + \" \" + target);\n            } else {\n              this$.log(\"verbose\", \"watch\", \"updated \" + target);\n              httpPath = '';\n              try {\n                if (that = /^[^/].*$/.exec(path.relative(dir.path, target))) {\n                  httpPath = \"/\" + that[0];\n                }\n              } catch (e$) {}\n              return this$.broadcast({\n                type: 'update',\n                path: httpPath,\n                reload: shouldReload(httpPath)\n              });\n            }\n          }\n        }));\n      });\n      return watchObjs;\n    };\n    prototype.createServer = function(dirs){\n      var inject, encoding, i$, x$, ref$, len$, app, y$, opts, ref1$, ref2$;\n      inject = [].concat(this.options.inject);\n      encoding = this.options.encoding;\n      if (this.options.builtinScript) {\n        inject = inject.concat({\n          which: new RegExp(\".*\\\\.html?$\"),\n          where: new RegExp(\"</(body|head|html)>\", \"i\"),\n          type: \"file\",\n          content: path.resolve(__dirname, '../client.html'),\n          prepend: true,\n          encoding: encoding\n        });\n      }\n      for (i$ = 0, len$ = (ref$ = [].concat(inject)).length; i$ < len$; ++i$) {\n        x$ = ref$[i$];\n        if (x$.type === \"file\") {\n          x$.content = path.resolve(this.basedir, x$.content);\n        }\n      }\n      app = (ref$ = this.options.connectApp) != null\n        ? ref$\n        : connect();\n      if (this.getLogLevel(this.options.log) >= this.logLevel.verbose) {\n        app.use(connect.logger(':ar-prefix :remote-addr :method \":url HTTP/:http-version\" :status :referrer :user-agent'));\n      }\n      for (i$ = 0, len$ = dirs.length; i$ < len$; ++i$) {\n        y$ = dirs[i$];\n        if (this.options.listDirectory) {\n          app.use(y$.target, connect.directory(y$.path, {\n            icons: true\n          }));\n        }\n        opts = (ref$ = (ref1$ = (ref2$ = {}, ref2$.path = y$.path, ref2$.target = y$.target, ref2$), ref1$.inject = inject, ref1$.encoding = encoding, ref1$), ref$.defaultPages = this.defaultPages, ref$);\n        app.use(y$.target, bind$(new InjectionRouter(opts), 'route'));\n        app.use(y$.target, connect['static'](y$.path));\n      }\n      return http.createServer(app);\n    };\n    prototype.broadcast = function(data){\n      var json, i$, x$, ref$, len$, ex, results$ = [];\n      try {\n        json = JSON.stringify(data);\n        this.log(\"debug\", \"broadcast\", \"to \" + this.websockets.length + \" sockets: \" + json);\n        for (i$ = 0, len$ = (ref$ = this.websockets).length; i$ < len$; ++i$) {\n          x$ = ref$[i$];\n          results$.push(x$.send(json));\n        }\n        return results$;\n      } catch (e$) {\n        ex = e$;\n        return this.log(\"error\", \"broadcast\", ex.message);\n      }\n    };\n    return SimpleAutoreloadServer;\n  }());\n  connect.logger.token('ar-prefix', function(r){\n    return (function(it){\n      return it + \" httpd\".green;\n    })(\n    SimpleAutoreloadServer.logPrefix(r.headers.host));\n  });\n  out$.SimpleAutoreloadServer = SimpleAutoreloadServer;\n  function bind$(obj, key, target){\n    return function(){ return (target || obj)[key].apply(obj, arguments) };\n  }\n  function partialize$(f, args, where){\n    var context = this;\n    return function(){\n      var params = slice$.call(arguments), i,\n          len = params.length, wlen = where.length,\n          ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n      return len < wlen && len ?\n        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n    };\n  }\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n  function in$(x, xs){\n    var i = -1, l = xs.length >>> 0;\n    while (++i < l) if (x === xs[i]) return true;\n    return false;\n  }\n  function clone$(it){\n    function fun(){} fun.prototype = it;\n    return new fun;\n  }\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/node_modules/simple-autoreload-server/lib/watch.js":"/*\n * simple-autoreload-server v0.2.6 - 2016-10-14\n * <https://github.com/cytb/simple-autoreload-server>\n *\n * Copyright (c) 2016 cytb\n *\n * Licensed under the MIT License.\n */\n\n(function(){\n  var fs, path, RecursiveWatcher, out$ = typeof exports != 'undefined' && exports || this;\n  fs = require('fs');\n  path = require('path');\n  RecursiveWatcher = (function(){\n    RecursiveWatcher.displayName = 'RecursiveWatcher';\n    var prototype = RecursiveWatcher.prototype, constructor = RecursiveWatcher;\n    function RecursiveWatcher(arg$){\n      var ref$;\n      this.path = arg$.path, this.delay = (ref$ = arg$.delay) != null ? ref$ : 30, this.update = (ref$ = arg$.update) != null\n        ? ref$\n        : function(){}, this.error = (ref$ = arg$.error) != null\n        ? ref$\n        : function(){}, this.recursive = (ref$ = arg$.recursive) != null ? ref$ : false, this.followSymlinks = (ref$ = arg$.followSymlinks) != null ? ref$ : false;\n      this.watchers = [];\n    }\n    prototype.findDir = function(root){\n      var dirs, queue, dir, i$, ref$, len$, file, fullPath, node, ex;\n      dirs = [];\n      queue = [root];\n      while (dir = queue.shift()) {\n        try {\n          dirs.push(dir);\n          for (i$ = 0, len$ = (ref$ = fs.readdirSync(dir)).length; i$ < len$; ++i$) {\n            file = ref$[i$];\n            try {\n              fullPath = path.join(dir, file);\n              node = fs.lstatSync(fullPath);\n              if (!node.isDirectory() || (node.isSymbolicLink() && !this.followSymlinks)) {\n                continue;\n              }\n              queue.push(fullPath);\n            } catch (e$) {\n              ex = e$;\n              this.error(ex);\n            }\n          }\n        } catch (e$) {\n          ex = e$;\n          this.error(ex);\n        }\n      }\n      return dirs;\n    };\n    prototype.start = function(arg$){\n      var ref$, ref1$, sessions, dirs, this$ = this;\n      ref$ = arg$ != null\n        ? arg$\n        : {}, this.update = (ref1$ = ref$.update) != null\n        ? ref1$\n        : this.update, this.error = (ref1$ = ref$.error) != null\n        ? ref1$\n        : this.error;\n      this.stop();\n      sessions = {};\n      dirs = this.recursive && this.findDir(this.path) || [this.path];\n      return this.watchers = dirs.map(function(dir){\n        return fs.watch(dir).on('error', bind$(this$, 'error')).on('change', function(type, name){\n          var file, ref$, timer, timeStamp, expired, time;\n          file = path.join(dir, name);\n          ref$ = (ref$ = sessions[file]) != null\n            ? ref$\n            : sessions[file] = {\n              timeStamp: Date.now()\n            }, timer = ref$.timer, timeStamp = ref$.timeStamp;\n          if (timer != null) {\n            clearTimeout(timer);\n          }\n          expired = function(){\n            delete sessions[file];\n            return this$.update(type, file);\n          };\n          time = this$.delay - (Date.now() - timeStamp);\n          return sessions[file].timer = setTimeout(expired, time);\n        });\n      });\n    };\n    prototype.stop = function(){\n      this.watchers.forEach(function(it){\n        return it.close();\n      });\n      return this.watchers = [];\n    };\n    return RecursiveWatcher;\n  }());\n  out$.RecursiveWatcher = RecursiveWatcher;\n  function bind$(obj, key, target){\n    return function(){ return (target || obj)[key].apply(obj, arguments) };\n  }\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/node_modules/simple-autoreload-server/lib/option.js":"/*\n * simple-autoreload-server v0.2.6 - 2016-10-14\n * <https://github.com/cytb/simple-autoreload-server>\n *\n * Copyright (c) 2016 cytb\n *\n * Licensed under the MIT License.\n */\n\n(function(){\n  var Minimatch, path, isArray, convertToKeys, flatten, cloneRegex, optionsSource, ParseHelper, OptionHelper, split$ = ''.split, slice$ = [].slice, join$ = [].join, toString$ = {}.toString, out$ = typeof exports != 'undefined' && exports || this;\n  Minimatch = require('minimatch').Minimatch;\n  path = require('path');\n  isArray = (function(it){\n    return it instanceof Array;\n  });\n  convertToKeys = function(){\n    var toCamelCase;\n    toCamelCase = function(it){\n      var ref$, head, rest;\n      ref$ = split$.call(it, /-|_/), head = ref$[0], rest = slice$.call(ref$, 1);\n      return join$.call([head].concat(rest.map(function(it){\n        return it.replace(/^./, function(it){\n          return it.toUpperCase();\n        });\n      })), '');\n    };\n    return function(key, joiner, ch){\n      var ref$, i$, keys, leaf;\n      ch == null && (ch = '.');\n      ref$ = key.split(ch).map(toCamelCase), keys = 0 < (i$ = ref$.length - 1) ? slice$.call(ref$, 0, i$) : (i$ = 0, []), leaf = ref$[i$];\n      return [keys.join(joiner), leaf];\n    };\n  }();\n  flatten = function(array){\n    var fn$ = curry$(function(x$, y$){\n      return x$.concat(y$);\n    });\n    if (isArray(array)) {\n      while (array.some(isArray)) {\n        array = array.reduce(fn$, []);\n      }\n    }\n    return array;\n  };\n  cloneRegex = function(it){\n    var name, flag;\n    return new RegExp(it.source, (function(it){\n      return join$.call(it, '');\n    })((function(){\n      var ref$, results$ = [];\n      for (name in ref$ = {\n        global: it.global,\n        ignoreCase: it.ignoreCase,\n        multiline: it.multiline\n      }) {\n        flag = ref$[name];\n        results$.push(flag && name.charAt(0) || '');\n      }\n      return results$;\n    }())));\n  };\n  optionsSource = require(\"./option-list\").options;\n  ParseHelper = (function(){\n    ParseHelper.displayName = 'ParseHelper';\n    var prototype = ParseHelper.prototype, constructor = ParseHelper;\n    function ParseHelper(optionMap){\n      this.optionMap = optionMap;\n      this.parsed = {};\n      this.unknown = {};\n    }\n    prototype.set = function(out, fullKey, value){\n      var ref$, base, key, key$, i$, x$, len$;\n      ref$ = convertToKeys(fullKey, '.', '.'), base = ref$[0], key = ref$[1];\n      out = (ref$ = out[key$ = base || key]) != null\n        ? ref$\n        : out[key$] = [];\n      if (base) {\n        value = (ref$ = {}, ref$[key] = value, ref$);\n        for (i$ = 0, len$ = out.length; i$ < len$; ++i$) {\n          x$ = out[i$];\n          if (x$[key] == null) {\n            import$(x$, value);\n            return;\n          }\n        }\n      }\n      return out.push(value);\n    };\n    prototype.prepare = function(target, key, value){\n      var ref$, ref1$;\n      this.target = target;\n      this.key = key;\n      this.value = value != null ? value : true;\n      if (((ref$ = this.optionMap[this.target]) != null ? (ref1$ = ref$[this.key]) != null ? ref1$.type : void 8 : void 8) === 'boolean') {\n        return this.push();\n      }\n    };\n    prototype.push = function(value){\n      value == null && (value = this.value);\n      switch (false) {\n      case this.value == null:\n        this.put(this.target, this.key, value);\n        break;\n      case value == null:\n        this.set(this.unknown, \"rest\", value);\n      }\n      return this.value = null;\n    };\n    prototype.put = function(target, key, value){\n      var that, ref$, ref1$, ref2$;\n      if ((that = (ref$ = this.optionMap[target]) != null ? ref$[key] : void 8) != null) {\n        return this.set(this.parsed, that.label, value);\n      } else {\n        return this.set((ref2$ = (ref1$ = this.unknown)[target]) != null\n          ? ref2$\n          : ref1$[target] = {}, key, value);\n      }\n    };\n    return ParseHelper;\n  }());\n  OptionHelper = (function(){\n    OptionHelper.displayName = 'OptionHelper';\n    var prototype = OptionHelper.prototype, constructor = OptionHelper;\n    OptionHelper.parse = function(it){\n      return new OptionHelper(it).parse();\n    };\n    OptionHelper.readPattern = function(pattern, nocase, dots){\n      dots == null && (dots = false);\n      switch (toString$.call(pattern).slice(8, -1)) {\n      case 'Array':\n        return compose$(curry$(function(x$, y$){\n          return y$(x$);\n        }), bind$(pattern.map(partialize$.apply(arguments, [arguments.callee, [void 8, nocase, dots], [0]])), 'every'));\n      case 'String':\n        return bind$(new Minimatch(pattern, {\n          nocase: nocase,\n          dots: dots\n        }), 'match');\n      case 'RegExp':\n        return bind$(cloneRegex(pattern), 'test');\n      case 'Function':\n        return pattern;\n      default:\n        return function(){\n          return pattern;\n        };\n      }\n    };\n    function OptionHelper(optionList, defaults){\n      var i$, ref$, len$, optionEntry, key, value, ref1$, ref2$;\n      this.optionList = optionList != null ? optionList : optionsSource;\n      this.defaults = defaults != null\n        ? defaults\n        : {};\n      this.optionMap = {};\n      for (i$ = 0, len$ = (ref$ = this.optionList).length; i$ < len$; ++i$) {\n        optionEntry = ref$[i$];\n        for (key in optionEntry) {\n          value = optionEntry[key];\n          ((ref2$ = (ref1$ = this.optionMap)[key]) != null\n            ? ref2$\n            : ref1$[key] = {})[value] = optionEntry;\n        }\n      }\n    }\n    prototype.parse = function(argv){\n      var ope, i$, len$, arg, ref$, matched, isFullOption, negate, key, hasValue, value, target, j$, skeys;\n      argv == null && (argv = process.argv.slice(2));\n      ope = new ParseHelper(this.optionMap);\n      for (i$ = 0, len$ = argv.length; i$ < len$; ++i$) {\n        arg = argv[i$];\n        ref$ = (ref$ = /^-(-)?((no-|without-)?([^=]+))(=(.+))?/.exec(arg)) != null\n          ? ref$\n          : [], matched = ref$[0], isFullOption = ref$[1], negate = ref$[3], key = ref$[4], hasValue = ref$[5], value = ref$[6];\n        if (!matched) {\n          ope.push(arg);\n          continue;\n        }\n        ope.push();\n        target = \"label\";\n        if (isFullOption) {\n          if (!hasValue) {\n            value = !negate;\n          }\n        } else {\n          target = \"short\";\n          ref$ = split$.call(key, ''), skeys = 0 < (j$ = ref$.length - 1) ? slice$.call(ref$, 0, j$) : (j$ = 0, []), key = ref$[j$];\n          skeys.forEach(partialize$.apply(ope, [ope.put, [target, void 8, true], [1]]));\n        }\n        ope.prepare(target, key, value);\n      }\n      ope.push();\n      (function(){\n        this.full = this.label;\n        delete this.label;\n      }.call(ope.unknown));\n      return {\n        parsed: ope.parsed,\n        unknown: ope.unknown\n      };\n    };\n    prototype.defaultOption = function(option, key, entry, defaults, options){\n      var value, that;\n      value = (function(){\n        switch (false) {\n        case (that = option != null ? option[key] : void 8) == null:\n          return that;\n        case (that = defaults != null ? defaults[key] : void 8) == null:\n          return that(options, this.optionMap);\n        case (that = entry != null ? entry.def : void 8) == null:\n          return that;\n        default:\n          return null;\n        }\n      }.call(this));\n      return option[key] = (function(){\n        switch (entry.type) {\n        case 'number':\n          return (isArray(value) && value.pop() || value) * 1;\n        default:\n          return value;\n        }\n      }());\n    };\n    prototype.assure = function(options, defaults){\n      var nodes, i$, ref$, len$, entry, label, ref1$, base, key, primary, node, name, option;\n      defaults == null && (defaults = this.defaults);\n      options = import$({}, options);\n      nodes = {};\n      for (i$ = 0, len$ = (ref$ = this.optionList).length; i$ < len$; ++i$) {\n        entry = ref$[i$], label = entry.label;\n        ref1$ = convertToKeys(label, '', '.'), base = ref1$[0], key = ref1$[1];\n        if (!base) {\n          (fn$.call(this, options[key]));\n          this.defaultOption(options, key, entry, defaults[key] != null, options);\n          continue;\n        }\n        primary = nodes[base] == null;\n        ((ref1$ = nodes[base]) != null\n          ? ref1$\n          : nodes[base] = {})[key] = entry;\n        if (!primary) {\n          continue;\n        }\n        options[base] = compose$(fn1$, flatten)(fn2$);\n      }\n      for (base in nodes) {\n        node = nodes[base];\n        for (name in node) {\n          entry = node[name];\n          for (i$ = 0, len$ = (ref$ = options[base]).length; i$ < len$; ++i$) {\n            option = ref$[i$];\n            this.defaultOption(option, name, entry, defaults[base] != null, options);\n          }\n        }\n      }\n      return options;\n      function fn$(it){\n        isArray(it) && (options[key] = it[it.length - 1]);\n      }\n      function fn1$(it){\n        return typeof it == 'function' ? it(options[base]) : void 8;\n      }\n      function fn2$(obj){\n        var ref$;\n        switch (false) {\n        case typeof obj !== 'string':\n          return [(ref$ = {}, ref$[key] = obj, ref$)];\n        case obj != null:\n          return [];\n        case !isArray(obj):\n          return obj.map(arguments.callee);\n        case !isArray(obj[key]):\n          return obj[key].map(function(it){\n            var ref$;\n            return ref$ = clone$(obj), ref$[key] = it, ref$;\n          });\n        case obj[key] == null:\n          return [obj];\n        default:\n          return [];\n        }\n      }\n    };\n    return OptionHelper;\n  }());\n  out$.OptionHelper = OptionHelper;\n  function curry$(f, bound){\n    var context,\n    _curry = function(args) {\n      return f.length > 1 ? function(){\n        var params = args ? args.concat() : [];\n        context = bound ? context || this : this;\n        return params.push.apply(params, arguments) <\n            f.length && arguments.length ?\n          _curry.call(context, params) : f.apply(context, params);\n      } : f;\n    };\n    return _curry();\n  }\n  function import$(obj, src){\n    var own = {}.hasOwnProperty;\n    for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n    return obj;\n  }\n  function compose$() {\n    var functions = arguments;\n    return function() {\n      var i, result;\n      result = functions[0].apply(this, arguments);\n      for (i = 1; i < functions.length; ++i) {\n        result = functions[i](result);\n      }\n      return result;\n    };\n  }\n  function bind$(obj, key, target){\n    return function(){ return (target || obj)[key].apply(obj, arguments) };\n  }\n  function partialize$(f, args, where){\n    var context = this;\n    return function(){\n      var params = slice$.call(arguments), i,\n          len = params.length, wlen = where.length,\n          ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n      return len < wlen && len ?\n        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n    };\n  }\n  function clone$(it){\n    function fun(){} fun.prototype = it;\n    return new fun;\n  }\n}).call(this);\n","/home/travis/build/npmtest/node-npmtest-simple-autoreload-server/node_modules/simple-autoreload-server/lib/option-list.js":"/*\n * simple-autoreload-server v0.2.6 - 2016-10-14\n * <https://github.com/cytb/simple-autoreload-server>\n *\n * Copyright (c) 2016 cytb\n *\n * Licensed under the MIT License.\n */\n\n(function(){\n  var out$ = typeof exports != 'undefined' && exports || this;\n  out$.options = [\n    {\n      \"label\": \"path\",\n      \"short\": \"d\",\n      \"type\": \"string\",\n      \"def\": \".\",\n      \"help\": \"set directory to publish.\",\n      \"desc\": \"specifies root directory to publish.\"\n    }, {\n      \"label\": \"watch\",\n      \"short\": \"w\",\n      \"type\": \"pattern\",\n      \"def\": \"**/**\",\n      \"help\": \"pattern for file to watch.\",\n      \"desc\": \"pattern for file to watch.\\nif true, it matches any files, and matches nothing on false.\"\n    }, {\n      \"label\": \"reload\",\n      \"short\": \"r\",\n      \"type\": \"pattern\",\n      \"def\": false,\n      \"help\": \"pattern for file to reload the whole page.\",\n      \"desc\": \"pattern for file to reload the whole page.\\nwhether or not to reload actually depends on behavior of client script.\\nif true, it matches any files, and matches nothing on false.\"\n    }, {\n      \"label\": \"mount.path\",\n      \"short\": \"m\",\n      \"type\": \"string\",\n      \"def\": \".\",\n      \"help\": \"set additional directory to publish.\",\n      \"desc\": \"specifies additional directory to publish.\\n\\nprogram can accept multiple times in commandline.\\nother 'mount.*' options are attached to corresponding path by order in commandline.\",\n      \"examples\": {\n        \"command\": \"autoreload-server -H localhost -p 8080 -m ./html -m ./node_modules --mount.path ./build\",\n        \"result\": \"the server publishes content of './html', './node_modules' and './build' at 'https://localhost:8080/'.\\nif all of those directories contain 'index.html' and client requests 'https://localhost:8080/index.html',\\nthe first one will be sent ('./html/index.html' in this case).\"\n      }\n    }, {\n      \"label\": \"mount.target\",\n      \"short\": \"t\",\n      \"type\": \"string\",\n      \"def\": \"/\",\n      \"help\": \"server side path of mounted direcory\",\n      \"desc\": \"server side path of mounted direcory.\",\n      \"examples\": {\n        \"command\": \"autoreload-server . 8080 -m ./www/js -t /components\",\n        \"result\": \"the server publishes content of './' to server-root(http://localhost:8080/),\\n\\\"./www/js\\\" to \\\"/components\\\" (http://localhost:8080/components/).\"\n      }\n    }, {\n      \"label\": \"mount.watch\",\n      \"short\": \"W\",\n      \"type\": \"pattern\",\n      \"def\": \"**/**\",\n      \"help\": \"pattern of file to watch.\",\n      \"desc\": \"pattern of file to watch.\"\n    }, {\n      \"label\": \"host\",\n      \"short\": \"H\",\n      \"type\": \"string\",\n      \"def\": \"0.0.0.0\",\n      \"help\": \"set host address to publish.\",\n      \"desc\": \"specifies server address to listen.\\n'0.0.0.0' means listening all of the (ipv4) interfaces on computer.\"\n    }, {\n      \"label\": \"port\",\n      \"short\": \"p\",\n      \"type\": \"number\",\n      \"def\": \"8080\",\n      \"help\": \"set port to listen (http).\",\n      \"desc\": \"specifies server http(s) port to listen.\"\n    }, {\n      \"label\": \"config\",\n      \"short\": \"c\",\n      \"type\": \"string\",\n      \"def\": \".autoreload.json\",\n      \"help\": \"load options from json.\",\n      \"desc\": \"load json as config before starting server.\\nthe config overwritten by command-line options and function arguments.\\nall of specified pathes regarded as relative path from config location.\\n(function arguments, and command-line parameters as well.)\\n\\nthe server logs nothing when the default config does not exist.\"\n    }, {\n      \"label\": \"search-config\",\n      \"short\": null,\n      \"type\": \"boolean\",\n      \"def\": true,\n      \"help\": \"search for config json in parent directories.\",\n      \"desc\": \"search for config file in parent directories.\\nit is no harm when specified absolute path.\"\n    }, {\n      \"label\": \"list-directory\",\n      \"short\": \"l\",\n      \"type\": \"boolean\",\n      \"def\": true,\n      \"help\": \"enable directory listing.\",\n      \"desc\": \"enable directory listing.\\nit should be disabled if you want to invoke default request handler.\"\n    }, {\n      \"label\": \"browse\",\n      \"short\": \"b\",\n      \"type\": \"string\",\n      \"def\": false,\n      \"help\": \"open server url by platform default program.\",\n      \"desc\": \"invokes platform default program with argumemts after launched. \\n\\nif provided true via function argument \\nor '--browse' option followed by nothing via command-line, \\nthe program invokes the default with the server url.\\n\\nif the 'String' value was specified, it will be passed instead of the server url.\\nthe server does nothing if specified Boolean of 'false' or 'null'.\",\n      \"examples\": [\n        {\n          \"command\": \"autoreload-server -d . -p 8088 -H 192.168.1.15 -b\",\n          \"result\": \"opens https://192.168.1.15:8088/\"\n        }, {\n          \"command\": 'autoreload-server -d . -p 8088 -b \"http://server1.localdomain:80/\"',\n          \"result\": 'opens \"http://server1.localdomain:80/\"'\n        }\n      ]\n    }, {\n      \"label\": \"execute\",\n      \"short\": \"e\",\n      \"type\": \"string\",\n      \"def\": \"\",\n      \"help\": \"execute command when the server has prepared.\",\n      \"desc\": \"executes command when the server has been prepared.\\nthe command is passed to shell.\\nin other words it has not been invoked directly.\\n\\nyou can pass Array of above values or many times on command-line,\\nand then the server invokes with each values.\\n\",\n      \"examples\": {\n        \"command\": 'autoreload-server -e \"firefox\"',\n        \"result\": \"opens firefox via shell\"\n      }\n    }, {\n      \"label\": \"stop-on-exit\",\n      \"short\": \"k\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"exit when invoked process specified by \\\"execute\\\" died.\",\n      \"desc\": \"the server will stop when invoked process specified by 'execute' option died.\\nif there are multiple processes invoked by 'execute' option,\\nthe server keep running until all of that has been killed.\"\n    }, {\n      \"label\": \"ignore-case\",\n      \"short\": \"i\",\n      \"type\": \"boolean\",\n      \"def\": true,\n      \"help\": \"ignore case of glob patterns.\",\n      \"desc\": \"ignoring case of glob-string of patterns.\\n\\nthis option is no harm to regex pattern of 'pattern' type.\\nall of the glob patterns that were passed as 'String' type\\nvia function arguments or command-line option will be affected.\"\n    }, {\n      \"label\": \"include-hidden\",\n      \"short\": \"n\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"glob includes hidden files.\",\n      \"desc\": \"make globs to include hidden (dot) files.\\nthis option is no harm except for glob string patterns.\"\n    }, {\n      \"label\": \"default-pages\",\n      \"short\": null,\n      \"type\": \"pattern\",\n      \"def\": \"index.{htm,html}\",\n      \"help\": \"default page file pattern for directory request.\",\n      \"desc\": \"default page file pattern for directory request.\"\n    }, {\n      \"label\": \"encoding\",\n      \"short\": null,\n      \"type\": \"string\",\n      \"def\": \"utf-8\",\n      \"help\": \"encoding for reading texts and inject target files\",\n      \"desc\": \"encoding for reading texts and inject target files\"\n    }, {\n      \"label\": \"watch-delay\",\n      \"short\": null,\n      \"type\": \"number\",\n      \"def\": 20,\n      \"help\": \"delay time to supress duplicate watch event (ms).\",\n      \"desc\": \"delay time to supress duplicate watch event (in milil-seconds).\\nthe watch event is often fired multiple times in short duration.\"\n    }, {\n      \"label\": \"log\",\n      \"short\": \"v\",\n      \"type\": \"string\",\n      \"def\": \"normal\",\n      \"help\": \"set log-level\",\n      \"desc\": \"set log mode. choose from followings.\\n'silent' -> 'minimum' -> 'normal' -> 'verbose' -> 'noisy'\\n(number also acceptable: silent is 0, minimum is 1, ..., and noisy is 4)\"\n    }, {\n      \"label\": \"builtin-script\",\n      \"short\": null,\n      \"type\": \"boolean\",\n      \"def\": true,\n      \"help\": \"enable default built-in script injection.\",\n      \"desc\": \"enable injection of default built-in script.\\n\\nif you want to replace for built-in script by another script,\\nspecify this option to false or with negative prefix ('no-') without equal,\\nand use 'inject' option.\"\n    }, {\n      \"label\": \"client-module\",\n      \"short\": null,\n      \"type\": \"string\",\n      \"def\": true,\n      \"help\": \"expose client module to 'window' object.\",\n      \"desc\": \"expose client side built-in module to 'window' object.\\nif you want to use client module in built-in script, set true or String value.\\n\\nIf true,   module will be exposed to 'window.AutoreloadClient'.\\nIf String, module will be exposed in window with specified name.\\n\\nThis option does nothing when 'builtin-script' is false.\\nwhen the module is initialized, it emits the 'AutoreloadClient.*' events on 'window'.\\nsee 'examples'.\"\n    }, {\n      \"label\": \"client-log\",\n      \"short\": null,\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"inform client to log.\",\n      \"desc\": \"inform client to log.\\nthe server only send a option to client on connect by this option.\\nwhether or not to logs actually depends on behavior of client script.\"\n    }, {\n      \"label\": \"recursive\",\n      \"short\": \"R\",\n      \"type\": \"boolean\",\n      \"def\": true,\n      \"help\": \"watch sub-directories recursively.\",\n      \"desc\": \"watch sub-directories recursively. this may take a while at startup.\\nthe server does not detect cyclic structure and it may cause infinit loop.\\nunset follow-symlinks option if need.\"\n    }, {\n      \"label\": \"follow-symlinks\",\n      \"short\": \"L\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"follow symbolic-links. (requires 'recursive' option)\",\n      \"desc\": \"lookup files in symbolic-links target when watch directory. \\nthis option affects only when the resursive option is enabled.\"\n    }, {\n      \"label\": \"inject.content\",\n      \"short\": \"I\",\n      \"type\": \"string\",\n      \"def\": \"\",\n      \"help\": \"injects specified content.\",\n      \"desc\": \"injects specified content. see also: 'inject.type'.\\nif no inject.content options are provided,\\nand the file '.autoreload.html' exists in current directory\\n(or config json directory), server try to inject as a builtin-script.\"\n    }, {\n      \"label\": \"inject.type\",\n      \"short\": \"T\",\n      \"type\": \"string\",\n      \"def\": \"file\",\n      \"help\": 'type of \"inject.content\".',\n      \"desc\": \"specifies type of 'inject.content' option.\\n'file': treat 'inject.content' as file path.\\n'raw':  'inject.content' will be injected directly.\"\n    }, {\n      \"label\": \"inject.which\",\n      \"short\": \"F\",\n      \"type\": \"pattern\",\n      \"def\": \"**/**.{htm,html}\",\n      \"help\": \"specify pattern for injection target.\",\n      \"desc\": \"specify pattern for injection target.\"\n    }, {\n      \"label\": \"inject.where\",\n      \"short\": \"P\",\n      \"type\": \"string\",\n      \"def\": \"</(body|head|html)>\",\n      \"help\": \"specify regex string where to inject.\",\n      \"desc\": \"this is not a 'pattern' type.\\nspecify regex string where to inject.\\ncontent will be injected before matched string.\"\n    }, {\n      \"label\": \"inject.prepend\",\n      \"short\": \"E\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"insert content before matched.\",\n      \"desc\": \"change injection method to 'prepend'.\\nif true, content will be injected 'before' matched string.\"\n    }, {\n      \"label\": \"help\",\n      \"short\": \"h\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"show help\",\n      \"desc\": \"show help and exit.\\nignored if it was appeared on json or function arguments.\"\n    }, {\n      \"label\": \"version\",\n      \"short\": \"V\",\n      \"type\": \"boolean\",\n      \"def\": false,\n      \"help\": \"show version\",\n      \"desc\": \"shows version.\\nignored if it was appeared on json or function arguments.\"\n    }, {\n      \"label\": \"onmessage\",\n      \"short\": null,\n      \"type\": \"function\",\n      \"def\": null,\n      \"help\": \"onmessage event handler.\",\n      \"desc\": \"specifies server onmessage handler.\\nserver calls this function on broadcast the message.\",\n      \"nocli\": true\n    }, {\n      \"label\": \"connect-app\",\n      \"short\": null,\n      \"type\": \"object\",\n      \"def\": null,\n      \"help\": \"specify 'connect' app object as server base.\",\n      \"desc\": \"specifies 'connect' app object as server base.\\nserver middleware layers willbe stacked to this object.\",\n      \"nocli\": true\n    }\n  ];\n}).call(this);\n"}